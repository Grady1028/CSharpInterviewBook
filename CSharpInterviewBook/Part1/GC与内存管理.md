### GC与内存管理

---
#### GC垃圾回收
GC是垃圾回收（Garbage Collect）的缩写，是.NET核心机制的重要部分。它的基本工作原理就是遍历托管堆中的对象，标记哪些被使用对象（那些没人使用的就是所谓的垃圾），然后把可达对象转移到一个连续的地址空间（也叫压缩），其余的所有没用的对象内存被回收掉。

---
#### 一个引用对象的生命周期
- new创建对象并分配内存
- 对象初始化
- 对象操作、使用
- 资源清理（非托管资源）
- GC垃圾回收

---
#### 非托管资源回收
.NET中提供释放非托管资源的方式主要是：**Finalize()** 和 **Dispose()**。

- Dispose需要手动调用，在.NET中有两中调用方式：  

    ```
    //方式1：显示接口调用
    SomeType st1=new SomeType();
    //do sth
    st1.Dispose();
    
    //方式2：using()语法调用，自动执行Dispose接口
    using (var st2 = new SomeType())
    {
        //do sth
    }
    ```

- Finalize()可以确保非托管资源会被释放，但需要很多额外的工作（比如终结对象特殊管理），而且GC需要执行两次才会真正释放资源。听上去好像缺点很多，她唯一的优点就是不需要显示调用。

---
#### using() 语法是如何确保对象资源被释放的？
using() 只是一种语法形式，其本质还是try…finally的结构，可以保证Dispose始终会被执行。

---
#### GC.Collect()

尽量不要手动执行垃圾回收的方法：GC.Collect()。垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及Finalize方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用GC.Collect()来执行垃圾回收，一般GC会在最适合的时间进行垃圾回收。而且还需要注意的一点，在执行垃圾回收的时候，所有线程都是要被挂起的（如果回收的时候，代码还在执行，那对象状态就不稳定了，也没办法回收了）。

---
#### GC在哪些情况下回进行回收工作？
- 内存不足溢出时（0代对象充满时）
- Windwos报告内存不足时，CLR会强制执行垃圾回收
- CLR卸载AppDomian，GC回收所有
- 调用GC.Collect
- 其他情况，如主机拒绝分配内存，物理内存不足，超出短期存活代的存段门限

---
#### .NET中的托管堆中是否可能出现内存泄露的现象？
- 不正确的使用静态字段，导致大量数据无法被GC释放；
- 没有正确执行Dispose()，非托管资源没有得到释放；
- 不正确的使用终结器Finalize()，导致无法正常释放资源；
- 其他不正确的引用，导致大量托管对象无法被GC释放；
