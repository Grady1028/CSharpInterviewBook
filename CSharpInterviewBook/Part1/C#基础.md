### C#面试要点（1）值类型、引用类型、装箱与拆箱
---
#### 值类型和引用类型的区别  
-  **值类型** 

    描述 | 类型
    ---|---
    有符号整形 | int,short,long,sbyte
    无符号整形 | uint,ushort,ulong,byte
    浮点型 | float,double
    字符型 | char
    高精度小数 | decimal
    布尔型 | bool
    枚举 | enum
    结构 | struct
- **引用类型**
    描述 | 类型
    ---|---
    类 | class,object,string
    接口 | interface
    数组 | 如int[],int[,]
    委托 | delegate
- **两者区别在于内存分配**
    1. **栈**：线程栈，**存放值类型、引用类型在托管堆中的地址**，由操作系统管理，一个线程包含一个栈，栈中的值类型在其作用域结束后会被清理，效率很高。
    2. **托管堆**：**存放引用类型**，托管堆中的对象由GC来管理和释放。  
- **值类型一直都存储在栈上面吗？所有的引用类型都存储在托管堆上面吗？**  
    1. 单独的值类型变量，如局部值类型变量都是存储在栈上面的；
    2. 当值类型是自定义class的一个字段、属性时，它随引用类型存储在托管堆上，此时它是引用类型的一部分；
    3. 所有的引用类型肯定都是存放在托管堆上的。
    4. 结构体（值类型）中定义引用类型字段，结构体是存储在栈上，其引用变量字段只存储内存地址，指向堆中的引用实例。
- **对象复制的差异**  
    将值类型的变量赋值给另一个变量（或者作为参数传递），会执行一次值复制。将引用类型的变量赋值给另一个引用类型的变量，它复制的值是引用对象的内存地址，因此赋值后就会多个变量指向同一个引用对象实例。
        
---
#### out和ref关键字  
- out 和 ref都指示编译器传递参数地址，在行为上是相同的；
- ref要求参数在使用之前要显式初始化，out要在方法内部初始化；
- out 和 ref不可以用于重载，就是不能定义Method(ref int a)和Method(out int a)这样的重载，从编译角度看，二者的实质是相同的，只是使用时有区别；

---
#### 装箱和拆箱
-  值类型均隐式派生自System.ValueType。**只有值类型才有装箱、拆箱两个状态，而引用类型一直都在箱子里**。
- **装箱即值类型转换为引用类型**，过程如下：  
    1. 在堆中申请内存，内存大小为值类型的大小，再加上额外固定空间（引用类型的标配：TypeHandle和同步索引块）；
    2. 将值类型的字段值拷贝新分配的内存中；
    3. 返回新引用对象的地址
- **拆箱即把装箱后的引用类型转换为值类型**，过程如下（以object转换为int为例）：
    1. 检查实例对象（object o）是否有效，如是否为null，其装箱的类型与拆箱的类型（int）是否一致，如检测不合法，抛出异常；
    2. 指针返回，就是获取装箱对象（object o）中值类型字段值的地址；
    3. 字段拷贝，把装箱对象（object o）中值类型字段值拷贝到栈上，意思就是创建一个新的值类型变量来存储拆箱后的值；
- 性能损耗
    1. **一般来说，装箱的性能开销更大**，装箱过程是需要创建一个新的引用类型对象实例，拆箱过程则需要创建一个值类型字段，开销更低。
    2. **避免隐式装箱**，如下代码：  
    
        ```
        int i = 10;  
        ArrayList list = new ArrayList(3);  
        list.Add(i);
        ```
        查看Add方法的定义：  
        
        ```
        public virtual int Add(object value);
        ```
        可知list在执行Add方法时做了隐式拆箱，造成了性能的损耗。

---
#### HashTable和Dictionary的区别
- HashTable不支持泛型，而Dictionary支持泛型。比如Dictionary<string, string>是一个泛型。
- Hashtable的元素属于Object类型，存取值类型数据需要装箱拆箱，造成一定的性能损耗。
-  Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型。而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。


