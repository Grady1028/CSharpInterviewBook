### 面向对象基础2
---
#### const和readonly有什么区别
- 初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在构造方法里赋值。 
- 修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段 。 
- const是编译时常量，在编译时确定该值，且值在编译时被内联到代码中；readonly是运行时常量，在运行时确定该值。
- const默认是静态的；而readonly如果设置成静态需要显示声明 。 
- 支持的类型时不同，const只能修饰基元类型或值为null的其他引用类型；readonly可以是任何类型。
---
#### 常量const有什么风险  

常量的风险就是不支持跨程序集版本更新，常量值更新后，所有使用该常量的代码都必须重新编译。  

---
#### 静态成员和非静态成员的区别
- 静态变量使用 static 修饰符进行声明，静态成员在加类的时候就被加载（静态字段是随类型对象存放在Load Heap上的），通过类进行访问。
- 不带有static 修饰符声明的变量称做非静态变量，在对象被实例化时创建，通过对象进行访问 。
- 一个类的所有实例的同一静态变量都是同一个值，同一个类的不同实例的同一非静态变量可以是不同的值 。
- 静态函数的实现里不能使用非静态成员，如非静态变量、非静态函数等。

---
#### 自动属性有什么风险
因为自动属性的私有字段是由编译器命名的，后期不宜随意修改，比如在序列化中会导致字段值丢失。

---
#### 下面的代码输出什么结果

```
List<Action> acs = new List<Action>(5);
for (int i = 0; i < 5; i++)
{
    acs.Add(() => { Console.WriteLine(i); });
}
acs.ForEach(ac => ac());
```
输出了 5 5 5 5 5，全是5！因为闭包中的共享变量i会被提升为委托对象的公共字段，生命周期延长了。

---
#### 委托
- C#中的委托都继承自System.Delegate类型；
- 委托类型的声明与方法签名类似，有返回值和参数；
- 委托是一种可以封装命名（或匿名）方法的引用类型，把方法当做指针传递，但委托是面向对象、类型安全的；
- 事件可以理解为一种特殊的委托，事件内部是基于委托来实现的。
