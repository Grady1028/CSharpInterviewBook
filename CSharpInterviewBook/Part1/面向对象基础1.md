### 面向对象基础1
---
#### 类型  
- 每一个类型（如System.Int32）在内存中都会有一个唯一的类型对象，通过GetType()可以获取该对象；
- 类型对象（Object Type）存储在内存中一个独立的区域，叫加载堆（Load Heap），加载堆是在进程创建的时候创建的，不受GC垃圾回收管制，因此类型对象一经创建就不会被释放的，他的生命周期从AppDomain创建到结束；
- 每个引用对象都包含两个附加成员：TypeHandle和同步索引块，其中TypeHandle就指向该对象对应的类型对象；
- 类型对象的加载由class loader负责，在第一次使用前加载；
- 类型中的静态字段就是存储在加载堆上，所以说静态字段是全局的，而且不会释放；
---
#### 方法表
- 方法表加载时父类在前子类在后，首先加载的是固定的4个来自System.Object的虚方法：ToString, Equals, GetHashCode, and Finalize；
- 然后加载父类A的虚方法；
- 加载自己的方法；
- 最后是构造方法：静态构造函数.cctor()，对象构造函数.ctor()；
---
#### .NET中的继承本质
- 继承是可传递的，子类是对父类的扩展，必须继承父类方法，同时可以添加新方法。
- 子类可以调用父类方法和字段，而父类不能调用子类方法和字段。 
- 子类不光继承父类的公有成员，也继承了私有成员，只是不可直接访问。
- new关键字在虚方法继承中的阻断作用，中断某一虚方法的继承传递。
- 执行就近原则：对于同名字段或者方法，编译器是按照其顺序查找来引用的，也就是首先访问离它创建最近的字段或者方法。
--- 
#### 抽象类
**基本特点：**  
- 抽象类使用Abstract声明，抽象方法也是用Abstract标示；
- 抽象类不能被实例化；
- 抽象类可以提供抽象方法，也可以提供非抽象方法；抽象方法必须定义在抽象类中；
- 抽象类可以继承一个抽象类；
- 抽象类不能被密封（不能使用sealed）；
- 同类Class一样，只支持单继承；
---
#### 接口
**基本特点：**
- 接口使用interface声明；
- 接口类似于抽象基类，不能直接实例化接口；
- 接口中的方法都是抽象方法，不能有实现代码，实现接口的任何非抽象类型都必须实现接口的所有成员：
- 接口成员是自动公开的，且不能包含任何访问修饰符。
- 接口自身可从多个接口继承，类和结构可继承多个接口，但接口不能继承类。
--- 
#### virtual、sealed、override和abstract的区别
- virtual申明虚方法的关键字，说明该方法可以被重写
- sealed说明该类不可被继承
- override重写基类的方法
- abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化。
--- 
#### 重载与覆盖的区别
**重载**：当类包含两个名称相同但签名不同(方法名相同,参数列表不相同)的方法时发生方法重载。用方法重载来提供在语义上完成相同而功能不同的方法。  
**覆写**：在类的继承中使用，通过覆写子类方法可以改变父类虚方法的实现。
